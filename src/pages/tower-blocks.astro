---
import GameLayout from '@/layouts/game.astro';
---

<GameLayout>
	<Fragment slot="head-scripts">
		<meta name="viewport" content="width=device-width,user-scalable=no" />
	</Fragment>

	<button id="back-button" class="back-button">
		<div class="back-button-box">
			<span class="back-button-elem">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 46 40">
					<path
						d="M46 20.038c0-.7-.3-1.5-.8-2.1l-16-17c-1.1-1-3.2-1.4-4.4-.3-1.2 1.1-1.2 3.3 0 4.4l11.3 11.9H3c-1.7 0-3 1.3-3 3s1.3 3 3 3h33.1l-11.3 11.9c-1 1-1.2 3.3 0 4.4 1.2 1.1 3.3.8 4.4-.3l16-17c.5-.5.8-1.1.8-1.9z"
					></path>
				</svg>
			</span>
			<span class="back-button-elem">
				<svg viewBox="0 0 46 40">
					<path
						d="M46 20.038c0-.7-.3-1.5-.8-2.1l-16-17c-1.1-1-3.2-1.4-4.4-.3-1.2 1.1-1.2 3.3 0 4.4l11.3 11.9H3c-1.7 0-3 1.3-3 3s1.3 3 3 3h33.1l-11.3 11.9c-1 1-1.2 3.3 0 4.4 1.2 1.1 3.3.8 4.4-.3l16-17c.5-.5.8-1.1.8-1.9z"
					></path>
				</svg>
			</span>
		</div>
	</button>

	<div id="container">
		<div id="game"></div>
		<div id="score">0</div>
		<div id="instructions">Click (or press the space bar) to place the block</div>
		<div class="game-over">
			<h2>Game Over</h2>
			<p>You did great, you're the best.</p>
			<p>Click or space bar to start again</p>
		</div>
		<div class="game-ready">
			<div>
				<h1 id="start-message">Incase you were bored</h1>
				<button type="button" id="start-button"> Start</button>
			</div>
			<div></div>
		</div>
	</div>
</GameLayout>

<script>
	import { navigate } from 'astro:transitions/client';
	import { gsap, Power1 } from 'gsap';
	import * as THREE from 'three';

	interface BlockReturn {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		placed?: any;
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		chopped?: any;
		plane: 'x' | 'y' | 'z';
		direction: number;
		bonus?: boolean;
	}

	document.addEventListener('astro:page-load', () => {
		const backButton = document.getElementById('back-button');
		if (backButton) {
			backButton.addEventListener('click', (e) => {
				e.preventDefault();
				e.stopPropagation();
				navigate('/');
			});
		}

		console.clear();

		class Stage {
			private container: HTMLElement | null;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			private camera: any;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			private scene: any;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			private renderer: any;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			private light: any;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			private softLight: any;

			constructor() {
				// container

				this.container = document.getElementById('game');

				// renderer

				this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });

				this.renderer.setSize(window.innerWidth, window.innerHeight);
				this.renderer.setClearColor('#D0CBC7', 1);
				this.container?.appendChild(this.renderer.domElement);

				// scene

				this.scene = new THREE.Scene();

				// camera

				const aspect = window.innerWidth / window.innerHeight;
				const d = 20;

				this.camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, -100, 1000);
				this.camera.position.x = 2;
				this.camera.position.y = 2;
				this.camera.position.z = 2;
				this.camera.lookAt(new THREE.Vector3(0, 0, 0));

				// light

				this.light = new THREE.DirectionalLight(0xffffff, 0.5);
				this.light.position.set(0, 499, 0);
				this.scene.add(this.light);

				this.softLight = new THREE.AmbientLight(0xffffff, 0.4);
				this.scene.add(this.softLight);

				window.addEventListener('resize', () => this.onResize());
				this.onResize();
			}

			setCamera(y: number, speed: number = 0.3) {
				gsap.to(this.camera.position, { y: y + 4, ease: Power1.easeInOut, duration: speed });
				gsap.to(this.camera.lookAt, { y: y, ease: Power1.easeInOut, duration: speed });
			}

			onResize() {
				const viewSize = 30;
				this.renderer.setSize(window.innerWidth, window.innerHeight);
				this.camera.left = window.innerWidth / -viewSize;
				this.camera.right = window.innerWidth / viewSize;
				this.camera.top = window.innerHeight / viewSize;
				this.camera.bottom = window.innerHeight / -viewSize;
				this.camera.updateProjectionMatrix();
			}

			render = function (this: Stage) {
				this.renderer.render(this.scene, this.camera);
			};

			add = function (this: Stage, elem: HTMLElement) {
				this.scene.add(elem);
			};

			remove = function (this: Stage, elem: HTMLElement) {
				this.scene.remove(elem);
			};
		}

		class Block {
			STATES = { ACTIVE: 'active', STOPPED: 'stopped', MISSED: 'missed' };
			MOVE_AMOUNT = 12;
			dimension = { width: 0, height: 0, depth: 0 };
			position = { x: 0, y: 0, z: 0 };

			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			mesh: any;
			state: string;
			index: number;
			speed: number;
			direction: number;
			colorOffset: number;
			color: THREE.Color | number;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			material: any;

			workingPlane: string;
			workingDimension: string;

			targetBlock: Block;

			constructor(block: Block) {
				// set size and position

				this.targetBlock = block;

				this.index = (this.targetBlock ? this.targetBlock.index : 0) + 1;
				this.workingPlane = this.index % 2 ? 'x' : 'z';
				this.workingDimension = this.index % 2 ? 'width' : 'depth';

				// set the dimensions from the target block, or defaults.

				this.dimension.width = this.targetBlock ? this.targetBlock.dimension.width : 10;
				this.dimension.height = this.targetBlock ? this.targetBlock.dimension.height : 2;
				this.dimension.depth = this.targetBlock ? this.targetBlock.dimension.depth : 10;

				this.position.x = this.targetBlock ? this.targetBlock.position.x : 0;
				this.position.y = this.dimension.height * this.index;
				this.position.z = this.targetBlock ? this.targetBlock.position.z : 0;

				this.colorOffset = this.targetBlock
					? this.targetBlock.colorOffset
					: Math.round(Math.random() * 100);

				// set color
				if (!this.targetBlock) {
					this.color = 0x333344;
				} else {
					let offset = this.index + this.colorOffset;
					var r = Math.sin(0.3 * offset) * 55 + 200;
					var g = Math.sin(0.3 * offset + 2) * 55 + 200;
					var b = Math.sin(0.3 * offset + 4) * 55 + 200;
					this.color = new THREE.Color(r / 255, g / 255, b / 255);
				}

				// state

				this.state = this.index > 1 ? this.STATES.ACTIVE : this.STATES.STOPPED;

				// set direction

				this.speed = -0.1 - this.index * 0.005;
				if (this.speed < -4) {
					this.speed = -4;
				}

				this.direction = this.speed;

				// create block

				const geometry = new THREE.BoxGeometry(
					this.dimension.width,
					this.dimension.height,
					this.dimension.depth,
				);

				geometry.applyMatrix4(
					new THREE.Matrix4().makeTranslation(
						this.dimension.width / 2,
						this.dimension.height / 2,
						this.dimension.depth / 2,
					),
				);

				this.material = new THREE.MeshToonMaterial({
					color: this.color,
					// shading: THREE.FlatShading,
				});
				this.mesh = new THREE.Mesh(geometry, this.material);
				this.mesh.position.set(
					this.position.x,
					this.position.y + (this.state == this.STATES.ACTIVE ? 0 : 0),
					this.position.z,
				);

				if (this.state == this.STATES.ACTIVE) {
					this.position[this.workingPlane as keyof typeof this.position] =
						Math.random() > 0.5 ? -this.MOVE_AMOUNT : this.MOVE_AMOUNT;
				}
			}

			reverseDirection() {
				this.direction = this.direction > 0 ? this.speed : Math.abs(this.speed);
			}

			place(): BlockReturn {
				this.state = this.STATES.STOPPED;

				let overlap =
					this.targetBlock.dimension[
						this.workingDimension as keyof typeof this.targetBlock.dimension
					] -
					Math.abs(
						this.position[this.workingPlane as keyof typeof this.position] -
							this.targetBlock.position[
								this.workingPlane as keyof typeof this.targetBlock.position
							],
					);

				const blocksToReturn: BlockReturn = {
					plane: this.workingPlane as keyof typeof this.position,
					direction: this.direction,
				};

				if (this.dimension[this.workingDimension as keyof typeof this.dimension] - overlap < 0.3) {
					overlap = this.dimension[this.workingDimension as keyof typeof this.dimension];
					blocksToReturn.bonus = true;
					this.position.x = this.targetBlock.position.x;
					this.position.z = this.targetBlock.position.z;
					this.dimension.width = this.targetBlock.dimension.width;
					this.dimension.depth = this.targetBlock.dimension.depth;
				}

				if (overlap > 0) {
					let choppedDimensions = {
						width: this.dimension.width,
						height: this.dimension.height,
						depth: this.dimension.depth,
					};
					choppedDimensions[this.workingDimension as keyof typeof choppedDimensions] -= overlap;
					this.dimension[this.workingDimension as keyof typeof this.dimension] = overlap;

					let placedGeometry = new THREE.BoxGeometry(
						this.dimension.width,
						this.dimension.height,
						this.dimension.depth,
					);
					placedGeometry.applyMatrix4(
						new THREE.Matrix4().makeTranslation(
							this.dimension.width / 2,
							this.dimension.height / 2,
							this.dimension.depth / 2,
						),
					);
					let placedMesh = new THREE.Mesh(placedGeometry, this.material);

					let choppedGeometry = new THREE.BoxGeometry(
						choppedDimensions.width,
						choppedDimensions.height,
						choppedDimensions.depth,
					);
					choppedGeometry.applyMatrix4(
						new THREE.Matrix4().makeTranslation(
							choppedDimensions.width / 2,
							choppedDimensions.height / 2,
							choppedDimensions.depth / 2,
						),
					);
					let choppedMesh = new THREE.Mesh(choppedGeometry, this.material);

					let choppedPosition = {
						x: this.position.x,
						y: this.position.y,
						z: this.position.z,
					};

					if (
						this.position[this.workingPlane as keyof typeof this.position] <
						this.targetBlock.position[this.workingPlane as keyof typeof this.targetBlock.position]
					) {
						this.position[this.workingPlane as keyof typeof this.position] =
							this.targetBlock.position[
								this.workingPlane as keyof typeof this.targetBlock.position
							];
					} else {
						choppedPosition[this.workingPlane as keyof typeof choppedPosition] += overlap;
					}

					placedMesh.position.set(this.position.x, this.position.y, this.position.z);
					choppedMesh.position.set(choppedPosition.x, choppedPosition.y, choppedPosition.z);

					blocksToReturn.placed = placedMesh;

					if (!blocksToReturn.bonus) {
						blocksToReturn.chopped = choppedMesh;
					}
				} else {
					this.state = this.STATES.MISSED;
				}

				this.dimension[this.workingDimension as keyof typeof this.dimension] = overlap;

				return blocksToReturn;
			}

			tick() {
				if (this.state == this.STATES.ACTIVE) {
					const value = this.position[this.workingPlane as keyof typeof this.position];
					if (value > this.MOVE_AMOUNT || value < -this.MOVE_AMOUNT) {
						this.reverseDirection();
					}

					this.position[this.workingPlane as keyof typeof this.position] += this.direction;
					this.mesh.position[this.workingPlane] =
						this.position[this.workingPlane as keyof typeof this.position];
				}
			}
		}

		class Game {
			STATES = {
				LOADING: 'loading',
				PLAYING: 'playing',
				READY: 'ready',
				ENDED: 'ended',
				RESETTING: 'resetting',
			};

			stage: Stage;

			blocks: Block[] = [];
			state: string = this.STATES.LOADING;

			// groups

			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			newBlocks: any;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			placedBlocks: any;
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			choppedBlocks: any;

			// UI elements

			scoreContainer: HTMLElement | null;
			mainContainer: HTMLElement | null;
			startButton: HTMLElement | null;
			instructions: HTMLElement | null;

			constructor() {
				this.stage = new Stage();

				this.mainContainer = document.getElementById('container');
				this.scoreContainer = document.getElementById('score');
				this.startButton = document.getElementById('start-button');
				this.instructions = document.getElementById('instructions');
				this.scoreContainer!.innerHTML = '0';

				this.newBlocks = new THREE.Group();
				this.placedBlocks = new THREE.Group();
				this.choppedBlocks = new THREE.Group();

				this.stage.add(this.newBlocks);
				this.stage.add(this.placedBlocks);
				this.stage.add(this.choppedBlocks);

				this.addBlock();
				this.tick();

				this.updateState(this.STATES.READY);

				document.addEventListener('keydown', (e) => {
					if (e.key == 'Space') {
						this.onAction();
					}
				});

				document.addEventListener('click', () => {
					this.onAction();
				});

				document.addEventListener('touchstart', (e) => {
					e.preventDefault();
					// this.onAction();

					// ☝️ this triggers after click on android so you
					// insta-lose, will figure it out later.
				});
			}

			updateState(newState: string) {
				for (let key in this.STATES) {
					this.mainContainer?.classList.remove(this.STATES[key as keyof typeof this.STATES]);
				}

				this.mainContainer?.classList.add(newState);
				this.state = newState;
			}

			onAction() {
				switch (this.state) {
					case this.STATES.READY:
						this.startGame();
						break;
					case this.STATES.PLAYING:
						this.placeBlock();
						break;
					case this.STATES.ENDED:
						this.restartGame();
						break;
				}
			}

			startGame() {
				if (this.state != this.STATES.PLAYING) {
					this.scoreContainer!.innerHTML = '0';
					this.updateState(this.STATES.PLAYING);
					this.addBlock();
				}
			}

			restartGame() {
				this.updateState(this.STATES.RESETTING);

				let oldBlocks = this.placedBlocks.children;
				let removeSpeed = 0.2;
				let delayAmount = 0.02;

				for (let i = 0; i < oldBlocks.length; i++) {
					gsap.to(oldBlocks[i].scale, {
						duration: removeSpeed,
						x: 0,
						y: 0,
						z: 0,
						delay: (oldBlocks.length - i) * delayAmount,
						ease: Power1.easeIn,
						onComplete: () => this.placedBlocks.remove(oldBlocks[i]),
					});
					gsap.to(oldBlocks[i].rotation, {
						duration: removeSpeed,
						y: 0.5,
						delay: (oldBlocks.length - i) * delayAmount,
						ease: Power1.easeIn,
					});
				}

				const cameraMoveSpeed = removeSpeed * 2 + oldBlocks.length * delayAmount;
				this.stage.setCamera(2, cameraMoveSpeed);

				let countdown = { value: this.blocks.length - 1 };
				gsap.to(countdown, {
					value: 0,
					duration: cameraMoveSpeed,
					onUpdate: () => {
						this.scoreContainer!.innerHTML = String(Math.round(countdown.value));
					},
				});

				this.blocks = this.blocks.slice(0, 1);

				setTimeout(() => {
					this.startGame();
				}, cameraMoveSpeed * 1000);
			}

			placeBlock() {
				const currentBlock = this.blocks[this.blocks.length - 1];
				const newBlocks: BlockReturn | undefined = currentBlock?.place();

				this.newBlocks.remove(currentBlock?.mesh);

				if (newBlocks?.placed) {
					this.placedBlocks.add(newBlocks?.placed);
				}

				if (newBlocks?.chopped) {
					this.choppedBlocks.add(newBlocks?.chopped);
					let positionParams = {
						y: '-=30',
						ease: Power1.easeIn,
						onComplete: () => this.choppedBlocks.remove(newBlocks?.chopped),
						x: '0',
						z: '0',
					};

					let rotateRandomness = 10;
					let rotationParams = {
						delay: 0.05,
						x:
							newBlocks.plane == 'z'
								? Math.random() * rotateRandomness - rotateRandomness / 2
								: 0.1,
						z:
							newBlocks.plane == 'x'
								? Math.random() * rotateRandomness - rotateRandomness / 2
								: 0.1,
						y: Math.random() * 0.1,
					};
					if (
						newBlocks.chopped.position[newBlocks.plane] > newBlocks.placed.position[newBlocks.plane]
					) {
						positionParams[newBlocks.plane] = '+=' + 40 * Math.abs(newBlocks.direction);
					} else {
						positionParams[newBlocks.plane] = '-=' + 40 * Math.abs(newBlocks.direction);
					}
					gsap.to(newBlocks.chopped.position, { ...positionParams, duration: 1 });
					gsap.to(newBlocks.chopped.rotation, { ...rotationParams, duration: 1 });
				}

				this.addBlock();
			}

			addBlock() {
				const lastBlock = this.blocks[this.blocks.length - 1];

				if (lastBlock && lastBlock.state == lastBlock.STATES.MISSED) {
					return this.endGame();
				}

				this.scoreContainer!.innerHTML = String(this.blocks.length - 1);

				const newKidOnTheBlock = new Block(lastBlock!);
				this.newBlocks.add(newKidOnTheBlock.mesh);
				this.blocks.push(newKidOnTheBlock);

				this.stage.setCamera(this.blocks.length * 2);

				if (this.blocks.length >= 5) {
					this.instructions?.classList.add('hide');
				}
			}

			endGame() {
				this.updateState(this.STATES.ENDED);
			}

			tick() {
				this.blocks[this.blocks.length - 1]?.tick();
				this.stage.render();
				requestAnimationFrame(() => {
					this.tick();
				});
			}
		}

		new Game();
	});
</script>

<style>
	.back-button {
		position: relative;
		z-index: 1000;
		display: block;
		overflow: hidden;
		width: 56px;
		height: 56px;
		margin: 0;
		border: 0;
		background-color: transparent;
		outline: none;
		cursor: pointer;
	}

	.back-button::before,
	.back-button::after {
		content: '';
		position: absolute;
		inset: 7px;
		border-radius: 50%;
	}

	.back-button::before {
		@apply border-neutral;

		border: 4px solid;
		transition:
			opacity 0.4s cubic-bezier(0.77, 0, 0.175, 1) 80ms,
			transform 0.5s cubic-bezier(0.455, 0.03, 0.515, 0.955) 80ms;
	}

	.back-button::after {
		@apply border-neutral-focus;

		border: 4px solid;
		opacity: 0%;
		transition:
			opacity 0.4s cubic-bezier(0.165, 0.84, 0.44, 1),
			transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
		transform: scale(1.3);
	}

	.back-button:hover::before,
	.back-button:focus::before {
		opacity: 0%;
		transition:
			opacity 0.4s cubic-bezier(0.165, 0.84, 0.44, 1),
			transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
		transform: scale(0.7);
	}

	.back-button:hover::after,
	.back-button:focus::after {
		opacity: 100%;
		transition:
			opacity 0.4s cubic-bezier(0.77, 0, 0.175, 1) 80ms,
			transform 0.5s cubic-bezier(0.455, 0.03, 0.515, 0.955) 80ms;
		transform: scale(1);
	}

	.back-button-box {
		position: absolute;
		top: 0;
		left: 0;
		display: flex;
	}

	.back-button-elem {
		@apply fill-neutral;

		display: block;
		width: 20px;
		height: 20px;
		margin: 17px 18px 0;
		transform: rotate(180deg);
	}

	.back-button:hover .back-button-box,
	.back-button:focus .back-button-box {
		transition: 0.4s;
		transform: translateX(-56px);
	}

	#container {
		width: 100%;
		height: calc(100vh - 18rem);
	}

	#container #score {
		@apply top-0;

		position: absolute;
		width: 100%;
		color: rgb(51 66 52);
		font-size: 10vh;
		text-align: center;
		transition: transform 0.5s ease;
		transform: translateY(-200px) scale(1);
	}

	#container #game {
		position: absolute;
		inset: 0;
	}

	#container .game-over {
		@apply top-0;

		position: absolute;
		left: 0;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		width: 100%;
		height: 85%;
	}

	#container .game-over * {
		color: rgb(51 66 52);
		opacity: 0%;
		transition:
			opacity 0.5s ease,
			transform 0.5s ease;
		transform: translateY(-50px);
	}

	#container .game-over h2 {
		margin: 0;
		padding: 0;
		font-size: 40px;
	}

	#container .game-ready {
		@apply top-0;

		position: absolute;
		left: 0;
		display: flex;
		flex-direction: column;
		justify-content: space-around;
		align-items: center;
		width: 100%;
		height: 100%;
	}

	#container .game-ready #start-message,
	#container .game-ready #start-button {
		width: 100%;
		margin: 0.75rem auto;
		color: rgb(51 66 52);
		font-size: 30px;
		text-align: center;
		opacity: 0%;
		transition:
			opacity 0.5s ease,
			transform 0.5s ease;
		transform: translateY(-50px);
	}

	#container .game-ready #start-button {
		padding: 10px 20px;
		border: 3px solid rgb(51 66 52);
		background-color: transparent;
	}

	#container #instructions {
		position: absolute;
		top: 16vh;
		left: 0;
		width: 100%;
		text-align: center;
		opacity: 0%;
		transition:
			opacity 0.5s ease,
			transform 0.5s ease;
	}

	#container #instructions.hide {
		opacity: 0% !important;
	}

	#container.playing #score,
	#container.resetting #score {
		transform: translateY(0) scale(1);
	}

	#container.playing #instructions {
		opacity: 100%;
	}

	#container.ready .game-ready #start-message,
	#container.ready .game-ready #start-button {
		opacity: 100%;
		transform: translateY(0);
	}

	#container.ended #score {
		transform: translateY(6vh) scale(1.5);
	}

	#container.ended .game-over * {
		opacity: 100%;
		transform: translateY(0);
	}

	#container.ended .game-over p {
		transition-delay: 0.3s;
	}
</style>
